smallGroup <- 'Week'
standard <- c('DateGroup','Key')
withVersion <- c('DateGroup','Version','Key')
periods <- 4
lagPeriods <- 4
validateDate <- '2015-40'
# get a lag date after which data are not used to calculate historical average and standard deviation
lag <-calendar.df[length(calendar.df[,1])-lagPeriods, ]
lag <- with(lag, ifelse(lag[,smallGroup] < 10, paste(lag[,bigGroup], lag[,smallGroup], sep='-0'), paste(lag[,bigGroup], lag[,smallGroup], sep='-')))
# get the start date for pouches shipped per complaint rma AND data for tracker data (including part replacement, early failures, service codes, etc.)
startString <- findStartDate(calendar.df, bigGroup, smallGroup, 'OneYear')
startString.tracker <- startString
# use the makeDateGorupAndFillGaps function to properly format data that was read in from SQL
pouches.df <- makeDateGroupAndFillGaps(calendar.df, pouches.df, bigGroup, smallGroup, c('Key'), startString)
complaints.df <- makeDateGroupAndFillGaps(calendar.df, complaints.df, bigGroup, smallGroup, c('Key'), startString)
codes.df <- makeDateGroupAndFillGaps(calendar.df, codes.df, bigGroup, smallGroup, c('Key'), startString.tracker)
parts.df <- makeDateGroupAndFillGaps(calendar.df, parts.df, bigGroup, smallGroup, c('Key'), startString.tracker)
failures.df <- makeDateGroupAndFillGaps(calendar.df, failures.df, bigGroup, smallGroup, c('Version','Key'), startString.tracker)
rmasShip.df <- makeDateGroupAndFillGaps(calendar.df, rmasShip.df, bigGroup, smallGroup, c('Version','Key'), startString.tracker)
instShip.df <- makeDateGroupAndFillGaps(calendar.df, instShip.df, bigGroup, smallGroup, c('Version','Key'), startString.tracker)
instBuilt.df <- makeDateGroupAndFillGaps(calendar.df, instBuilt.df, bigGroup, smallGroup, c('Key'), startString.tracker)
leadingEF.df <- makeDateGroupAndFillGaps(calendar.df, leadingEF.df, bigGroup, smallGroup, c('Key','RecordedValue'), startString.tracker)
leadEFmanf.df <- makeDateGroupAndFillGaps(calendar.df, leadEFmanf.df, bigGroup, smallGroup, c('Key','RecordedValue'), startString.tracker)
# split the early failure data into service and production
failures.prod <- failures.df[failures.df[,'Key'] %in% c('DOA','ELF'), ]
failures.serv <- failures.df[failures.df[,'Key'] %in% c('SDOA','SELF'), ]
# use the computeRollingRateAndAddStats function to format data for plotting (for leading indicators, don't roll)
pouchesPerComplaint <- computeRollingRateAndAddStats(complaints.df, pouches.df, c('DateGroup','Key'), c('DateGroup','Key'), c('DateGroup'), periods, lag, startString)
partsPerServiceInst <- computeRollingRateAndAddStats(rmasShip.df, parts.df, c('DateGroup','Key'), c('DateGroup','Key'), c('DateGroup'), periods, lag, startString)
codesPerServiceInst <- computeRollingRateAndAddStats(rmasShip.df, codes.df, c('DateGroup','Key'), c('DateGroup','Key'), c('DateGroup'), periods, lag, startString)
leadingEFperRMA <- computeRollingRateAndAddStats(complaints.df, leadingEF.df, c('DateGroup','Key'),c('DateGroup','Key','RecordedValue'), c('DateGroup'), 1, lag, startString)
leadEFmanfperBuild <- computeRollingRateAndAddStats(instBuilt.df, leadEFmanf.df, c('DateGroup','Key'), c('DateGroup','Key','RecordedValue'), c('DateGroup'), 1, lag, startString)
# for early failures, the average and standard deviations need to include both DOA/ELF for Production and SDOA/SELF for Service (i.e. cumulative rate)
earlyFailures.prod  <- computeRollingRateAndAddStats(instShip.df, failures.prod, c('DateGroup','Key'), c('DateGroup','Key'), c('DateGroup'), periods, lag, startString)
earlyFailures.prod$average <- mean(with(earlyFailures.prod[as.character(earlyFailures.prod[,'DateGroup'])<=lag, ], aggregate(RollingRate~DateGroup, FUN=sum))[,2], na.rm=TRUE)
earlyFailures.prod$sdev <- sd(with(earlyFailures.prod[as.character(earlyFailures.prod[,'DateGroup'])<=lag, ], aggregate(RollingRate~DateGroup, FUN=sum))[,2], na.rm=TRUE)
earlyFailures.serv  <- computeRollingRateAndAddStats(rmasShip.df, failures.serv, c('DateGroup','Key'), c('DateGroup','Key'), c('DateGroup'), periods, lag, startString)
earlyFailures.serv$average <- mean(with(earlyFailures.serv[as.character(earlyFailures.serv[,'DateGroup'])<=lag, ], aggregate(RollingRate~DateGroup, FUN=sum))[,2], na.rm=TRUE)
earlyFailures.serv$sdev <- sd(with(earlyFailures.serv[as.character(earlyFailures.serv[,'DateGroup'])<=lag, ], aggregate(RollingRate~DateGroup, FUN=sum))[,2], na.rm=TRUE)
earlyFailures.all <- rbind(earlyFailures.prod, earlyFailures.serv)
earlyFailures.all$Department <- with(earlyFailures.all, ifelse(Key %in% c('DOA','ELF'), 'Production', 'Service'))
# determine if data points are pass or fail for charts that have limits ---------- MAKE CHANGES TO LIMITS HERE!!!
pouchesPerComplaint <- markForReview(pouchesPerComplaint, -2, c('Key'))
partsPerServiceInst <- markForReview(partsPerServiceInst, 2, c('Key'))
codesPerServiceInst <- markForReview(codesPerServiceInst, 3, c('Key'), TRUE, 0.01)
earlyFailures.all <- markForReview(earlyFailures.all, 2, c('Key'))
# do work for FYI charts (no limits)
rc.df <- merge(merge(with(rootCause.df, aggregate(thirtyDay~FailedPartDesc, FUN=sum)), with(rootCause.df, aggregate(netNinetyDay~FailedPartDesc, FUN=sum)), by='FailedPartDesc'), with(rootCause.df, aggregate(Record~FailedPartDesc, FUN=sum)), by='FailedPartDesc')
rc.df <- rc.df[with(rc.df, order(-Record, -thirtyDay)), ][1:10,]
thirty <- rc.df[,c('FailedPartDesc','thirtyDay','Record')]; colnames(thirty) <- c('Part','Record','Total'); thirty$Key <- 'Thirty Days'
thirty$Part <- factor(thirty$Part, levels = thirty[order(thirty$Total, thirty$Record), 'Part'])
ninety <- rc.df[,c('FailedPartDesc','netNinetyDay','Record')]; colnames(ninety) <- c('Part','Record','Total'); ninety$Key <- 'Ninety Days (net)'
rc.df <- rbind(thirty, ninety)
version.earlyFailures.prod <- computeRollingRateAndAddStats(instShip.df, failures.prod, c('DateGroup','Version','Key'), c('DateGroup','Version','Key'), c('DateGroup','Version'), periods, lag, startString)
version.earlyFailures.serv <- computeRollingRateAndAddStats(rmasShip.df, failures.serv, c('DateGroup','Version','Key'), c('DateGroup','Version','Key'), c('DateGroup','Version'), periods, lag, startString)
version.earlyFailures.all <- rbind(version.earlyFailures.serv, version.earlyFailures.prod)
# convert the service codes from characters to integers for ordering
codesPerServiceInst$Key <- as.integer(codesPerServiceInst$Key)
# make charts for the web hub
# Limit charts
# location of validated date line
x.val <- which(as.character(unique(pouchesPerComplaint[,'DateGroup']))==validateDate)
# annotations for pouches shipped per complaint RMA
x_positions <- c('2015-30','2015-37')
annotations <- c('Port\nWeld\nFix', 'Heat\nPress\nFix')
y_positions <- pouchesPerComplaint[as.character(pouchesPerComplaint[,'DateGroup']) %in% x_positions, 'RollingRate'] - 140
p.reliability <- ggplot(pouchesPerComplaint, aes(x=DateGroup, y=RollingRate, group=Key, color=Color)) + geom_line(color='black') + geom_point() + scale_color_manual(values=c('blue','red'), name='Key', guide=FALSE) + expand_limits(y=0) + geom_hline(aes(yintercept=Limits), color='red', lty='dashed') + theme(text=element_text(size=18), axis.text.x=element_text(angle=90, hjust=1,color='black',size=14), axis.text.y=element_text(hjust=1,color='black',size=14)) + labs(title='Pouches Shipped per Complaint RMA:\nLimit = -2 standard deviations', x='Date\n(Year-Week)', y='4-week Rolling Average') + scale_x_discrete(breaks = as.character(unique(pouchesPerComplaint[,'DateGroup']))[seq(1,length(as.character(unique(pouchesPerComplaint[,'DateGroup']))),4)]) + annotate("text",x=x_positions,y=y_positions,label=annotations, size=4) + geom_vline(aes(xintercept=x.val),color='mediumseagreen')
# annotations for pouches shipped per complaint RMA
x_positions <- c('2016-08')
annotations <- c('CAPA-13226')
y_positions <- max(earlyFailures.all[as.character(earlyFailures.all[,'DateGroup']) %in% x_positions, 'RollingRate'])
p.failures <- ggplot(earlyFailures.all, aes(x=DateGroup, y=RollingRate, fill=Key)) + geom_bar(stat='identity') + scale_fill_manual(values=c('darkgreen','darkseagreen','dodgerblue','lightskyblue')) + geom_hline(aes(yintercept=Limits), color='black', lty='dashed') + geom_hline(aes(yintercept=Limits+sdev), color='red', lty='dashed') + facet_wrap(~Department, ncol=1) + theme(text=element_text(size=18), axis.text.x=element_text(angle=90, hjust=1,color='black',size=14), axis.text.y=element_text(hjust=1,color='black',size=14)) + labs(title='Early Failures per Instruments Shipped:\nLimit = +3sd, FYI = +2sd', x='Date', y='4-week Rolling Average') + scale_x_discrete(breaks=as.character(unique(earlyFailures.all[,'DateGroup']))[seq(1,length(as.character(unique(earlyFailures.all[,'DateGroup']))),4)]) + annotate("text",x=x_positions,y=y_positions,label=annotations, size=4) + scale_y_continuous(label=percent) + geom_vline(aes(xintercept=x.val),color='mediumseagreen')
# FYI charts
p.parts <- ggplot(partsPerServiceInst, aes(x=DateGroup, y=RollingRate, group=Key)) + geom_line(color='black') + geom_point(color='black') + facet_wrap(~Key, scale='free_y') + geom_hline(aes(yintercept=Limits), color='blue', lty='dashed') + theme(text=element_text(size=18), axis.text.x=element_text(angle=90, hjust=1, color='black',size=12), axis.text.y=element_text(hjust=1,color='black',size=14)) + labs(title="Parts Replacement per RMAs Shipped:\nFYI Limit = +2 standard deviations", x='Date\n(Year-Week)\nPlunger block gasket, peltier assembly, and sealbar assembly include old and new part numbers.', y='4-week Rolling Average') + scale_x_discrete(breaks = as.character(unique(partsPerServiceInst[,'DateGroup']))[seq(1,length(as.character(unique(partsPerServiceInst[,'DateGroup']))),6)]) + scale_y_continuous(label=percent)
p.codes <- ggplot(codesPerServiceInst, aes(x=DateGroup, y=RollingRate, group=Key)) + geom_line(color='black') + geom_point(color='black') + facet_wrap(~Key, scale='free_y') + geom_hline(aes(yintercept=Limits), color='blue', lty='dashed') + theme(text=element_text(size=18), axis.text.x=element_text(angle=90, hjust=1, color='black',size=14), axis.text.y=element_text(hjust=1,color='black',size=14)) + labs(title='Code Usage per RMAs Shipped:\nFYI Limit = +3 standard deviations', x='Date', y='4-week Rolling Average') + scale_x_discrete(breaks = as.character(unique(codesPerServiceInst[,'DateGroup']))[seq(1,length(as.character(unique(codesPerServiceInst[,'DateGroup']))),6)]) + scale_y_continuous(label=percent)
p.fyi.failures <- ggplot(na.omit(version.earlyFailures.all), aes(x=DateGroup, y=RollingRate, fill=Key)) + geom_bar(stat='identity') + scale_fill_manual(values=c('darkgreen','darkseagreen','dodgerblue','lightskyblue'),name='Type') + geom_hline(aes(yintercept=0.035), color='black', lty='dashed') + facet_wrap(~Version, ncol=1) + theme(text=element_text(size=16), axis.text.x=element_text(angle=90, hjust=1,color='black',size=14), axis.text.y=element_text(hjust=1,color='black',size=14)) + labs(title='Early Failure Rate by Instrument Version:\nGoal = 3.5% of Instruments Shipped', x='Date\n(Year-week)', y='4-week Rolling Average') + scale_x_discrete(breaks=as.character(unique(version.earlyFailures.all[,'DateGroup']))[seq(1,length(as.character(unique(version.earlyFailures.all[,'DateGroup']))),4)]) + scale_y_continuous(label=percent)
p.fyi.rootcause <- ggplot(rc.df, aes(x=Part, y=Record, fill=Key, order=Key)) + geom_bar(stat='identity') + coord_flip() + scale_fill_manual(values=c('DarkGreen','DodgerBlue')) + theme(text=element_text(size=18), axis.text=element_text(size=12, color='black'), axis.text.x=element_text(hjust=1, color='black',size=12)) + labs(title='Last 90 Days: Top Ten Failed Parts', x='Part Description', y='Count of Failures')
# ADD CODE TO MAKE IT SO THE LABELS ARE LINKED TO A COLOR... NOT SURE HOW TO DO THIS!!!
myPal <- brewer.pal(length(unique(leadingEFperRMA$RecordedValue)), 'Paired')
names(myPal) <- levels(leadingEFperRMA$RecordedValue)
p.indicator <- ggplot(leadingEFperRMA, aes(x=DateGroup, y=RollingRate, fill=RecordedValue)) + geom_bar(stat='identity') + facet_wrap(~Key) + scale_y_continuous(label=percent) + theme(text=element_text(size=18), axis.text.x=element_text(angle=90, hjust=1,color='black',size=14), axis.text.y=element_text(hjust=1,color='black',size=14), legend.position='bottom', legend.title=element_blank()) + scale_x_discrete(breaks = as.character(unique(leadingEFperRMA[,'DateGroup']))[seq(1,length(as.character(unique(leadingEFperRMA[,'DateGroup']))),4)]) + guides(fill=guide_legend(nrow=3, byrow=TRUE)) + labs(title='Customer Reported Failure Mode in Early Failure RMAs:\nBy Customer Reported Date of Failure ', x='Report Date\n(Year-Week)', y='Failures/Complaint RMAs Opened') + scale_fill_manual(values = myPal)
p.badmanf <- ggplot(subset(leadEFmanfperBuild,Key %in% c('DOA','ELF')), aes(x=DateGroup, y=RollingRate, fill=RecordedValue)) + geom_bar(stat='identity') + facet_wrap(~Key) + scale_y_continuous(label=percent) + theme(text=element_text(size=18), axis.text.x=element_text(angle=90, hjust=1,color='black',size=14), axis.text.y=element_text(hjust=1,color='black',size=14), legend.position='bottom', legend.title=element_blank()) + scale_x_discrete(breaks = as.character(unique(leadEFmanfperBuild[,'DateGroup']))[seq(1,length(as.character(unique(leadEFmanfperBuild[,'DateGroup']))),4)]) + guides(fill=guide_legend(nrow=3, byrow=TRUE)) + labs(title='Customer Reported Failure Mode in Early Life Failures:\nBy Manufacturing Date of Instrument', x='Maufacturing Date\n(Year-Week)', y='Failures/Instruments Built') + scale_fill_manual(values=myPal)
# add code to plot the cumulative average hours run between failures in the install base
hours.df[,'YearMonth'] <- with(hours.df, ifelse(Month < 10, paste(Year,'-0',Month,sep=''), paste(Year,'-',Month,sep='')))
yearMonths <- unique(hours.df[,c('YearMonth')])
yearMonths <- yearMonths[order(yearMonths)]
x <- seq(1,length(hours.df$MTBF),1)
y <- hours.df$MTBF
y <- y[order(y)]
fit <- lm(y~x)
hoursBad <- cbind(y, dfbetas(fit))
hoursBad <- hoursBad[abs(hoursBad[,'x']) > 1,'y']
failures.clean <- hours.df[!(hours.df$MTBF %in% hoursBad), ]
avgMTBF <- c()
for (i in 1:length(yearMonths)) {
periodFail <- failures.clean[failures.clean[,'YearMonth'] <= yearMonths[i], ]
periodMTBF <- data.frame(YearMonth = yearMonths[i], MTBF_cum=mean(periodFail$MTBF))
avgMTBF <- rbind(avgMTBF, periodMTBF)
}
qtrBreaks <- yearMonths[seq(1,i,3)]
barMTBF <- with(failures.clean, aggregate(MTBF~YearMonth, FUN=mean))
head(barMTBG)
head(barMTBF)
tail(barMTBF)
library(lubridate)
month(Sys.Date())
year(Sys.Date())
exclude <- ifelse(month(Sys.Date()) < 10, paste(year(Sys.Date()),'-0',month(Sys.Date())), paste(year(Sys.Date()),'-',month(Sys.Date())))
exclude
exclude <- ifelse(month(Sys.Date()) < 10, paste(year(Sys.Date()),month(Sys.Date()),sep='-0'), paste(year(Sys.Date()),month(Sys.Date()),sep='-'))
exclude
tail(barMTBF)
barMTBF[barMTBF[,'YearMonth'] != exclude, ]
barMTBF <- barMTBF[barMTBF[,'YearMonth'] != exclude, ]
p <- ggplot(barMTBF, aes(x=YearMonth, y=MTBF)) + geom_bar(stat='identity', fill='dodgerblue') + geom_line(aes(x=YearMonth, y=MTBF_cum, group=1), color='blue', data = avgMTBF) + geom_point(aes(x=YearMonth, y=MTBF_cum), color='blue', data = avgMTBF)
p <- p + scale_x_discrete(breaks=qtrBreaks)
p <- p + theme(text=element_text(size=18, color='black'), plot.title=element_text(size=20), axis.text=element_text(color='black',size=16), axis.text.x=element_text(angle=90))
p + labs(title='Average Hours Run Between Failures:\nCummulative Field Population', x='Date', y='Average Hours Between Failures')
setwd('~')
list.files()
list.dirs()
list.files()
setwd('~/Coursera/DataProducts/app/')
list.files()
# load the necessary packages
library(shiny)
library(RCurl)
library(googleVis)
# source the data used by the app and do some preliminary cleaning
rx.df <- read.csv('PerscriptionCostsMedicare_2010-2014.csv', header = TRUE, sep = ',')
rx.df$Unit.Count <- as.numeric(gsub(pattern = ',', '', as.character(rx.df$Unit.Count)))
rx.df$Total.Spending <- as.numeric(substr(gsub(',','', as.character(rx.df$Total.Spending)), 2, 100))
rx.df <- rx.df[,c('Year','Indication','Unit.Count','Total.Spending')]
colnames(rx.df)[grep('Indication',colnames(rx.df))] <- 'Category'
rx.df$PrescriptionSpending <- rx.df$Total.Spending
rx.df$Key <- 'TopPrescriptions'
rx.df <- rx.df[rx.df$Year < 2014, ]
med.in.11 <- read.csv('MedicareInpatientCharges2011.csv', header = TRUE, sep = ','); med.in.11$Year <- 2011
med.in.12 <- read.csv('MedicareInpatientCharges2012.csv', header = TRUE, sep = ','); med.in.12$Year <- 2012
med.in.13 <- read.csv('MedicareInpatientCharges2013.csv', header = TRUE, sep = ','); med.in.13$Year <- 2013
med.in.df <- rbind(med.in.11[,c('Year','DRG.Definition','Provider.State','Total.Discharges','Average.Medicare.Payments')],
med.in.12[,c('Year','DRG.Definition','Provider.State','Total.Discharges','Average.Medicare.Payments')],
med.in.13[,c('Year','DRG.Definition','Provider.State','Total.Discharges','Average.Medicare.Payments')])
med.in.df$Category <- ifelse(regexpr(' W',as.character(med.in.df$DRG.Definition)) > 0,
tolower(substr(as.character(med.in.df$DRG.Definition), 7, (regexpr(' W',as.character(med.in.df$DRG.Definition))-1))),
tolower(substr(as.character(med.in.df$DRG.Definition), 7, 100)))
med.in.df$InPatientSpending <- with(med.in.df, Total.Discharges*Average.Medicare.Payments)
med.in.df$Key <- 'InPatient'
med.out.11 <- read.csv('MedicareOutpatientCharges2011.csv', header = TRUE, sep = ','); med.out.11$Year <- 2011
med.out.12 <- read.csv('MedicareOutpatientCharges2012.csv', header = TRUE, sep = ','); med.out.12$Year <- 2012
med.out.13 <- read.csv('MedicareOutpatientCharges2013.csv', header = TRUE, sep = ','); med.out.13$Year <- 2013
med.out.df <- rbind(med.out.11[,c('Year','APC','Provider.State','Outpatient.Services','Average.Total.Payments')],
med.out.12[,c('Year','APC','Provider.State','Outpatient.Services','Average.Total.Payments')],
med.out.13[,c('Year','APC','Provider.State','Outpatient.Services','Average.Total.Payments')])
med.out.df$Category <- tolower(substr(substr(as.character(med.out.df$APC), (regexpr('Level',as.character(med.out.df$APC))+6), 100), regexpr(' ',substr(as.character(med.out.df$APC), (regexpr('Level',as.character(med.out.df$APC))+6), 100))+1, 100))
med.out.df$OutPatientSpending <- with(med.out.df, Outpatient.Services*Average.Total.Payments)
med.out.df$Key <- 'OutPatient'
url <- 'http://www.census.gov/popest/data/state/asrh/2015/files/SCPRC-EST2015-18+POP-RES.csv'
pop <- getURL(url, ssl.verifypeer=0L, followlocation=1L)
pop <- read.csv(text=pop)
state.summary <- data.frame(StateAbb = state.abb, StateName = state.name)
pop <- merge(state.summary, pop, by.x='StateName', by.y='NAME')
colnames(pop)[grep('POPEST18PLUS2015', colnames(pop))] <- 'Population'
source('outputCareCategories.R')
install.packages('rsconnect')
install.packages("rsconnect")
install.packages("rsconnect")
install.packages("rsconnect")
install.packages("rsconnect")
rsconnect::setAccountInfo(name='bioaimie', token='99DDB64EF1F27243DE4EE76DE7220F1D', secret='6wPdfz52vZUipIZOS3jDtkOCPxeAlfpxToXMpXot')
library(rsconnect)
rsconnect::deployApp('~/Coursera/DataProducts/app/')
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
source('~/Coursera/DataProducts/app/filterCategory.R', echo=TRUE)
runApp()
head(med.in.df)
grep('extracranial procedures')
grep('extracranial procedures', med.in.df[,'Category'])
med.in.df[grep('extracranial procedures', med.in.df[,'Category']),]
med.in.df[grep('extracranial procedures', med.in.df[,'Category']),]
source('~/Coursera/DataProducts/app/filterCategory.R', echo=TRUE)
runApp()
a <- merge(with(med.in.df, aggregate(InPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb')
head(a)
filterCategory(a, 'extracranial procedures')
runApp()
head(a)
b <- a[a$Category == 'transient ischemia', ]
head(b)
gvisGeoChart(b, locationvar='Provider.State', colorvar='InPatientSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}"))
plot(gvisGeoChart(b, locationvar='Provider.State', colorvar='InPatientSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}")))
head(a)
runApp()
runApp()
runApp()
runApp()
runApp()
head(med.in.df)
cbind((merge(with(med.in.df, aggregate(InPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'), with((merge(with(med.in.df, aggregate(InPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'), InpatientSpending/Population))
cbind(merge(with(med.in.df, aggregate(InPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'),with(merge(with(med.in.df, aggregate(InPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'), InPatientSpending/Population))
c <- cbind(merge(with(med.in.df, aggregate(InPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'),with(merge(with(med.in.df, aggregate(InPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'), InPatientSpending/Population))
head(c)
runApp()
head(a)
3005712/552166
3005712/552166*100
3005712/552166*1000
runApp()
runApp()
runApp()
runApp()
head(a)
head(b)
head(b)
head(b)
head(c)
colnames(c)[5]
colnames(c)[5] <- 'PerCapitaSpending'
gvisGeoChart(c, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}"), markers = format('$###,###.##'))
gvisGeoChart(c, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}", vAxis="{format:'$###,###.##}"))
plot(gvisGeoChart(c, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}", vAxis="{format:'$###,###.##}")))
head(c)
head)c
head(c)
c <- c[c$Category == 'g.i. hemorrhage', ]
plot(gvisGeoChart(c, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}", vAxis="{format:'$###,###.##}")))
plot(gvisGeoChart(c, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}"))
)
plot(gvisGeoChart(c, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}", formats="{'$###,###.##}")))
plot(gvisGeoChart(c, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}", vAxis="{format:'$###,###.##}")))
plot(gvisGeoChart(c, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}", hAxis="{format:'$###,###.##}")))
plot(gvisGeoChart(c, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}", text="{format:'$###,###.##}")))
plot(gvisGeoChart(c, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}", labels="{format:'$###,###.##}")))
plot(gvisGeoChart(c, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}", markers="{format:'$###,###.##}")))
runApp()
rm(a,b,c)
runApp()
runApp()
a <- merge(with(med.out.df, aggregate(OutPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb')
head(a)
a$PerCapitaSpending <- round(a$OutPatientSpending/a$Population*1000,2)
head(a)
a <- a[a$Category == 'endoscopy upper airway']
a <- a[a$Category == 'endoscopy upper airway', ]
a
a <- a[a$Category == 'endoscopy upper airway', ]
gvisGeoChart(a, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}"))
plot(gvisGeoChart(a, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}")))
runApp()
runApp()
head(a)
head(rx.df)
# set working directory... take this out when the app goes live
setwd('~/Coursera/DataProducts/app')
# load the necessary packages
library(shiny)
library(RCurl)
library(googleVis)
# source the data used by the app and do some preliminary cleaning
rx.df <- read.csv('PerscriptionCostsMedicare_2010-2014.csv', header = TRUE, sep = ',')
rx.df$Unit.Count <- as.numeric(gsub(pattern = ',', '', as.character(rx.df$Unit.Count)))
rx.df$Total.Spending <- as.numeric(substr(gsub(',','', as.character(rx.df$Total.Spending)), 2, 100))
rx.df <- rx.df[,c('Year','Indication','Unit.Count','Total.Spending')]
colnames(rx.df)[grep('Indication',colnames(rx.df))] <- 'Category'
colnames(rx.df)[grep('Total.Spending',colnames(rx.df))] <- 'PrescriptionSpending'
rx.df$Key <- 'TopPrescriptions'
rx.df <- rx.df[rx.df$Year < 2014, ]
med.in.11 <- read.csv('MedicareInpatientCharges2011.csv', header = TRUE, sep = ','); med.in.11$Year <- 2011
med.in.12 <- read.csv('MedicareInpatientCharges2012.csv', header = TRUE, sep = ','); med.in.12$Year <- 2012
med.in.13 <- read.csv('MedicareInpatientCharges2013.csv', header = TRUE, sep = ','); med.in.13$Year <- 2013
med.in.df <- rbind(med.in.11[,c('Year','DRG.Definition','Provider.State','Total.Discharges','Average.Medicare.Payments')],
med.in.12[,c('Year','DRG.Definition','Provider.State','Total.Discharges','Average.Medicare.Payments')],
med.in.13[,c('Year','DRG.Definition','Provider.State','Total.Discharges','Average.Medicare.Payments')])
med.in.df$Category <- ifelse(regexpr(' W',as.character(med.in.df$DRG.Definition)) > 0,
tolower(substr(as.character(med.in.df$DRG.Definition), 7, (regexpr(' W',as.character(med.in.df$DRG.Definition))-1))),
tolower(substr(as.character(med.in.df$DRG.Definition), 7, 100)))
med.in.df$InPatientSpending <- with(med.in.df, Total.Discharges*Average.Medicare.Payments)
med.in.df$Key <- 'InPatient'
med.out.11 <- read.csv('MedicareOutpatientCharges2011.csv', header = TRUE, sep = ','); med.out.11$Year <- 2011
med.out.12 <- read.csv('MedicareOutpatientCharges2012.csv', header = TRUE, sep = ','); med.out.12$Year <- 2012
med.out.13 <- read.csv('MedicareOutpatientCharges2013.csv', header = TRUE, sep = ','); med.out.13$Year <- 2013
med.out.df <- rbind(med.out.11[,c('Year','APC','Provider.State','Outpatient.Services','Average.Total.Payments')],
med.out.12[,c('Year','APC','Provider.State','Outpatient.Services','Average.Total.Payments')],
med.out.13[,c('Year','APC','Provider.State','Outpatient.Services','Average.Total.Payments')])
med.out.df$Category <- tolower(substr(substr(as.character(med.out.df$APC), (regexpr('Level',as.character(med.out.df$APC))+6), 100), regexpr(' ',substr(as.character(med.out.df$APC), (regexpr('Level',as.character(med.out.df$APC))+6), 100))+1, 100))
med.out.df$OutPatientSpending <- with(med.out.df, Outpatient.Services*Average.Total.Payments)
med.out.df$Key <- 'OutPatient'
url <- 'http://www.census.gov/popest/data/state/asrh/2015/files/SCPRC-EST2015-18+POP-RES.csv'
pop <- getURL(url, ssl.verifypeer=0L, followlocation=1L)
pop <- read.csv(text=pop)
state.summary <- data.frame(StateAbb = state.abb, StateName = state.name)
pop <- merge(state.summary, pop, by.x='StateName', by.y='NAME')
colnames(pop)[grep('POPEST18PLUS2015', colnames(pop))] <- 'Population'
source('outputCareCategories.R')
source('filterCategory.R')
runApp()
runApp()
runApp()
runApp()
runApp()
b <- filterCategory(merge(with(med.out.df, aggregate(OutPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'),'debridement & destruction')
b$PerCapitaSpending <- round(b$OutPatientSpending/b$Population*1000,2)
head(b)
plot(gvisGeoChart(b, locationvar='Provider.State', colorvar='PerCapitaSpending', options = list(region='US', displayMode='regions', resolution='provinces', colorAxis="{colors:['#FFFFFF','#0000FF']}")))
runApp()
runApp()
head(rx.df)
runApp()
source('~/Coursera/DataProducts/app/filterCategory.R', echo=TRUE)
rm(b)
runApp()
runApp()
runApp()
runApp(display.mode='showcase')
runApp(display.mode = 'showcase')
runApp()
head(rx.df)
unique(rx.df$Category)
head(rx.df)
gvisPieChart(subset(rx.df, Year==2010), labelvar='Category', numvar='PrescriptionSpending')
plot(gvisPieChart(subset(rx.df, Year==2010), labelvar='Category', numvar='PrescriptionSpending'))
head(CityPopularity)
head(rx.df)
plot(gvisPieChart(rx.df[rx.df$Year==2010, c('Category','PrescriptionSpending')])
)
plot(gvisPieChart(with(rx.df[rx.df$Year==2010, c('Category','PrescriptionSpending')], aggregate(PrescriptionSpending~Category, FUN=sum)))
plot(gvisPieChart(with(rx.df[rx.df$Year==2010, c('Category','PrescriptionSpending')], aggregate(PrescriptionSpending~Category, FUN=sum))))
plot(gvisPieChart(with(rx.df[rx.df$Year==2010, c('Category','PrescriptionSpending')], aggregate(PrescriptionSpending~Category, FUN=sum))))
gvisLineChart(subset(rx.df, Year==2010), xvar='Year', yvar='PrescriptionSpending', chartid = 'Category')
plot(gvisLineChart(subset(rx.df, Year==2010), xvar='Year', yvar='PrescriptionSpending', chartid = 'Category'))
plot(gvisLineChart(subset(rx.df, Category=='Chemotherapy'), xvar='Year', yvar='PrescriptionSpending', chartid = 'Category'))
plot(gvisLineChart(with(subset(rx.df, Category=='Chemotherapy'), aggregate(PrescriptionSpending~Year, FUN=sum)), xvar='Year', yvar='PrescriptionSpending', chartid = 'Category'))
with(rx.df, aggregate(PrescriptionSpending~Year+Category, FUN=sum))
filterCategory(with(rx.df, aggregate(PrescriptionSpending~Year+Category, FUN=sum)), 'Chemotherapy', FALSE)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
head(rx.df)
a <- with(rx.df, aggregate(PrescriptionSpending~Year+Category, FUN=sum))
a <- a[a$Category == 'Chemotherapy', ]
gvisTable(a, options = list(width=1000), formats=list(Year='####', PrescriptionSpending='$###,###,###'))
plot(gvisTable(a, options = list(width=1000), formats=list(Year='####', PrescriptionSpending='$###,###,###')))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
head(a)
class(a$Category)
source('~/Coursera/DataProducts/app/filterCategory.R', echo=TRUE)
runApp()
rm(a)
runApp(display.mode = 'showcase')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp(display.mode = 'showcase')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
head(med.in)
head(med.in.df)
source('~/Coursera/DataProducts/app/filterCategory.R', echo=TRUE)
runApp()
head(rx.df)
filterCategory(with(rx.df, aggregate(PrescriptionSpending~Year+Category, FUN=sum)), 'Mental Health')
runApp()
runApp()
runApp()
runApp()
filterCategory(with(med.in.df, aggregate(InPatientSpending~Year+Category, FUN=sum)), 'extracranial procedures', TRUE)
with(med.in.df, aggregate(InPatientSpending~Year+Category, FUN=sum))
filterCategory(with(med.in.df, aggregate(InPatientSpending~Year+Category, FUN=sum)), 'extracranial procedures', TRUE)
source('~/Coursera/DataProducts/app/filterCategory.R', echo=TRUE)
filterCategory(with(med.in.df, aggregate(InPatientSpending~Year+Category, FUN=sum)), 'extracranial procedures', TRUE)
source('~/Coursera/DataProducts/app/filterCategory.R', echo=TRUE)
filterCategory(with(med.in.df, aggregate(InPatientSpending~Year+Category, FUN=sum)), 'extracranial procedures', TRUE)
source('~/Coursera/DataProducts/app/filterCategory.R', echo=TRUE)
filterCategory(with(med.in.df, aggregate(InPatientSpending~Year+Category, FUN=sum)), 'extracranial procedures', TRUE)
a <- filterCategory(with(med.in.df, aggregate(InPatientSpending~Year+Category, FUN=sum)), 'extracranial procedures', TRUE)
head(a)
class(a$TotalSpending)
filterCategory(with(med.in.df, aggregate(InPatientSpending~Year+Category, FUN=sum)), 'extracranial procedures')
filterCategory(with(med.in.df, aggregate(InPatientSpending~Year+Category, FUN=sum)), 'extracranial procedures')
source('~/Coursera/DataProducts/app/filterCategory.R', echo=TRUE)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
source('~/Coursera/DataProducts/app/filterCategory.R', echo=TRUE)
source('~/Coursera/DataProducts/app/outputCareCategories.R', echo=TRUE)
runApp(display.mode = 'showcase')
runApp()
filterCategory(with(rx.df, aggregate(PrescriptionSpending~Year+Category, FUN=sum)), 'Chemotherapy')
runApp()
filterCategory(merge(with(med.out.df, aggregate(OutPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'), 'debridement & destruction', TRUE)
a <- filterCategory(merge(with(med.out.df, aggregate(OutPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'), 'debridement & destruction', TRUE)
head(a)
head(med.out.df)
runApp()
View(med.in.df)
filterCategory(med.in.df, 'extracranial procedures')
a <- filterCategory(med.in.df, 'extracranial procedures')
head(a)
runApp()
runApp()
runApp()
runApp()
runApp()
filterCategory(with(rx.df, aggregate(PrescriptionSpending~Year+Category, FUN=sum)), 'Chemotherapy')
runApp()
runApp()
runApp()
head(rx.df)
runApp()
runApp()
rm(a)
runApp()
runApp()
runApp()
filterCategory(merge(with(med.out.df, aggregate(OutPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'), 'extracranial procedures')
filterCategory(merge(with(med.out.df, aggregate(OutPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'), 'extracranial procedure')
filterCategory(merge(with(med.out.df, aggregate(OutPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'), 'debridement & destruction')
filterCategory(merge(with(med.out.df, aggregate(OutPatientSpending~Provider.State+Category, FUN=sum)), pop[,c('StateAbb','Population')], by.x='Provider.State', by.y='StateAbb'), 'debridement & destruction')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
